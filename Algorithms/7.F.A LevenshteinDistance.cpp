// https://contest.yandex.ru/contest/25597/run-report/114731281/
// Принцип работы
// Принцип работы данной программы основан на алгоритме Фишера.
// Для определения количества атомарных состояний создает матрица размерами (N+1) x (M+1), где N - длина первого слова S,
// M - длина второго слова L. Первая строка заполняется числами 0...M, первый столбец заполняется числами 0...N.
// Остальные ячейки в таблице заполняются минимальным элементов из трех: dp[i, j -1], dp[i-1,j] и dp[i-1][j-1] + S[i-1] != L[j-1]
// Результатом является значение полученной в последней ячейки dp[N][M]  
// 
// Для решения данной задачи я использовал статью: https://habr.com/ru/articles/676858/
// 
// Доказательство корректности
// В матрице dp[i][j] будем хранить количество атомарных состояний для префиксов строк S[0:i-1] и L[0:j-1]
// Базовый случай динамики d[0][0] = 0 
// Переход динамики. В процессе перехода одна из строк увеличивается на 1 символ.
// Если до удлинения было не совпадение крайних символов, то при добавление нового символа количество атомарных состояний не измениться
// Иначе количество атомарных состояний увеличивается на 1.
// 
// Сначала длина первой строки состоит из 1 символа, длина второй строки постепенно увеличивается. Затем первая строка увеличивается на 1
// и снова проходимся по второй строке.
// 
// Результатом вычислений будет храниться в dp[N][M]
// 
// Временная сложность
// Так как в результате работы алгоритма необходимо пройти по всей таблице, то суммарная временная сложность составляет O(N*M),
// где N - длина первой строки, M - длина второй строки.
// 
// Пространственная сложность
// Для работы данного алгоритма необходимо создать вспомогательную таблицу dp размерами (2)x(M+1), в одной из строк таблицы будут
// храниться текущие значения, а в другой предыдущие. Поэтому суммарная пространственнаяы сложность составляет O(2*M) ~ O(M), где M - размер второй строки.
//

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>

int calculateDistance(const std::string& first_word, const std::string& second_word) {
	std::vector<std::vector<int>> dp_table(2, std::vector<int>(second_word.size() + 1, 0));
	std::iota(dp_table.begin()->begin(), dp_table.begin()->end(), 0);
	for (int i = 1; i <= first_word.size(); i++) {
		dp_table[1][0] = i;
		for (int j = 1; j <= second_word.size(); j++) {
			int argument = dp_table[0][j - 1] + (first_word[i-1] != second_word[j-1]);
			dp_table[1][j] = std::min({ dp_table[1][j - 1] + 1, dp_table[0][j] + 1, argument });
		}
		std::swap(dp_table[0], dp_table[1]);
	}
	return dp_table.begin()->back();

}

int levenshteiunDistance() {
	std::string first_word, second_word;
	std::cin >> first_word >> second_word;
	std::cout << calculateDistance(first_word, second_word);
	return 0;
}