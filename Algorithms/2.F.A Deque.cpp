// https://contest.yandex.ru/contest/22781/run-report/109423693/

// Принцип работы
//Реализация работы двухсторонней очереди(deque) основана на контейнере vector из стандартной библиотеки stl.
//В конструкторе класса создается вектор размером max_size для хранения максимального количества элементов в очереди.
//При добавлении элемента в конец очереди(push_back) добавляется элемент в вектор и голова очереди сдвигается 
// на один элемент вперед(увеличивается переменная head на 1).При удалении элемента из конца очереди переменная 
// head уменьшается на 1 и выводиться удаляемый элемент.
//При добавлении элемента в начало очереди(push_front) добавляется элемент в вектор и хвост очереди сдвигается 
// на один элемент назад(уменьшается переменная tail на 1).При удалении из начала очереди(pop_front) 
// выводиться удаляемый элемент и переменная tail увеличивается на 1.

// Доказательство коррекности. Здесь тоже не совсем понимаю что писать.
//При создании объекта класса Deque создается vector размером max_size.Переменным head, tail и dsize
//(индекс конца, начала и размер очереди) присваивается значение равным 0.
// 
//При добавлении элемента в конец очереди(push_back).Сначала добавляется значение в vector(vector[head] = hnumber), 
//затем переменная head увеличивается на единицу.Если после увеличения head равен max_size, то переменной присваивается значение 0.
//При добавлении элемента в начало очереди(push_front).Сначала переменная tail уменьшается на единицу, 
//затем добавляется значение в vector(vector[tail] = tnumber) затем.Если после уменьшения tail равен - 1, 
//то переменной присваивается значение max_size - 1.
//В обоих случаях увеличивается на 1 значение переменной dsize.Если значение dsize равно max_size, 
//то добавление нового элемента не происходит.Выводиться ошибка error.
//
//При удалении элемента с конца очереди(pop_back).Сначала уменьшается на 1 значение head, 
//затем выводиться удаляемый элемент(удаление / замена на ноль из vector не происходит).
//Если после уменьшение head равен - 1, то переменной присваивается значение max_size - 1.
//При удаление элемента с начала очереди(pop_front).Сначала выводиться удаляемый элемент, 
//затем значение переменной tail увеличивается на 1. Если после увеличения tail равен max_size, 
//то переменной присваивается значение 0.
//В обоих случаях уменьшается на 1 значение перменной dsize.Если dsize равно 0, 
//то удаление элемента не происходит.Выводиться ошибка error.

// Временная сложность
//При добавление новых элементов в очередь, если она не заполнена, выполняются три операции:
//	Добавление элемента в vector
//	Увеличение / уменьшение переменной head / tail.
//	Увеличение переменной dsize.
//Сложность каждой операции – константная О(1), поэтому и сложность всей операция добавления – константная О(1).
//Аналогично сложность операции удаления элементов из очереди также константная О(1).
//Поэтому общая сложность выполнения N количества команд составляется О(N).

// Пространственная сложность
// В конструкторе класса очереди при создании объекта создается vector размером max_size и в дальнейшем в нем перезаписываются данные.
// Также используется в программе используется переменные: head, til, dsize, max_size. Каждая из них занимает O(1) памяти.
// Поэтому общая пространственная сложность составляет O(max_size), где max_size - максимальный размер очереди.

#include <iostream>
#include <vector>

class Deque {
private:
	std::vector<int> queue;
	int head = 0;
	int tail = 0;
	int max_size;
	int dsize = 0;
public:
	Deque(int max_dsize) : queue(std::vector<int>(max_dsize)), max_size(max_dsize) {};
	void push_back(int number) {
		if (dsize != max_size) {
			queue[head] = number;
			head++;
			dsize++;
		}
		else {
			std::cout << "error" << std::endl;
		}
		head = head % max_size;
	}

	void push_front(int number) {
		if (dsize != max_size) {
			tail = (--tail + max_size) % max_size;
			dsize++;
			queue[tail] = number;
		}
		else {
			std::cout << "error" << std::endl;
		}
	}

	void pop_front() {
		if (dsize != 0) {
			std::cout << queue.at(tail) << std::endl;
			tail = ++tail % max_size;
			dsize--;
		}
		else {
			std::cout << "error" << std::endl;
		}
	}

	void pop_back() {
		if (dsize != 0) {
			head = (--head + max_size) % max_size;
			std::cout << queue.at(head) << std::endl;
			dsize--;
		}
		else {
			std::cout << "error" << std::endl;
		}
	}
};

int deque() {
	int number_command;
	int max_queue;
	std::cin >> number_command >> max_queue;
	Deque queue(max_queue);
	for (int i = 0; i < number_command; i++) {
		std::string command;
		std::cin >> command;
		if (command == "push_front") {
			int number;
			std::cin >> number;
			queue.push_front(number);
		} else if (command == "push_back") {
			int number;
			std::cin >> number;
			queue.push_back(number);
		}
		else if (command == "pop_front") {
			queue.pop_front();
		}
		else if (command == "pop_back") {
			queue.pop_back();
		}
	}
	return 0;
}
