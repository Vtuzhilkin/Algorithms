//https://contest.yandex.ru/contest/23815/run-report/110304714/

//Принцип работы
//Принцип работы реализованного алгоритма поиска схож с бинарным поиском в отсортированном массиве, только немного модифицированный.
//Берется средний элемент массива, который разбивает исходный на две части.В зависимости от среднего элемента и крайних значений
//полученных частей следующий средний элемент берется из правой или левой части массива, до тех пор пока средний элемент
//не станет равным искомому или искомый элемент не будет находится в диапазоне значений между средним и предыдущим от
//среднего элемента(в этом случае искомый элемент не найден)
//
//Доказательство корректности
//Так как получаемый массив имеет две части отсортированные по возрастанию, то при разбиение исходного массива на две части в общем случае,
//получается два массива один отсортированный по возрастанию, а другой нет(он как и исходный имеет две отсортированные по возрастанию части)
//
//Если искомый элемент больше среднего и меньше последнего элемента правой части, а так же правая часть отсортирована по возрастанию
//(т.е.средний элемент меньше последнего элемента правой части), то следующий средний элемент берется в правой части.
//
//Если искомый элемент меньше среднего и больше первого элемента левой части, а так же левая часть отсортирована по возрастанию
//(т.е.средний элемент больше первого элемента правой части), то следующий средний элемент берется в левой части.
//
//Если искомый элемент больше среднего
//и левая часть НЕ отсортирована по возрастанию, то следующий средний элемент берется из левой части
//иначе следующий средний элемент берется из правой части
//
//Если искомый элемент меньше среднего
//и правая часть НЕ отсортирована по возрастанию, то следующий средний элемент берется из правой части
//иначе следующий средний элемент берется из левой части
//
//Временная сложность
//Так как на каждый итерации исходный массив разбивается на две части, то в худшем случае алгоритм должен проделать log2(N),
//где N - количество элементов в исходном массиве, 2 - степень логарифма.
//Поэтому временная сложность данного алгоритма составляется O(ln(N)), где N - кол - во элементов.
//
//Пространственная сложность
//Помимо исходного массива, а также искомого элемента в памяти необходимо хранить индексы конца и начала части массива и
//индекс среднего элемента.Каждая переменная занимает O(1) памяти
//Значит общая пространственная сложность данного алгоритма составляет O(1).

#include <vector>
#include <cassert>

int search(const std::vector<int>& vec, const int& k,const int& start,const int& end) {
    int start_interval = start;
    int end_interval = end;
    int i = start_interval + (end_interval - start_interval) / 2;
    while (i > start + 1 && i < end - 1) {
        i = start_interval + (end_interval - start_interval) / 2;
        if (k > vec.at(i)) {
            start_interval = i;
        }
        else if (k < vec.at(i)) {
            end_interval = i;
        }
        else {
            return i;
        }
        if (k < vec.at(i) && k > vec.at(i - 1)) {
            return -1;
        }
    }
}

int broken_search(const std::vector<int>& vec, int k) {
    int start = -1;
    int end = vec.size();
    int i = 1;
    while (i > 0 && i < vec.size() - 1) {
        i = start + (end - start) / 2;
        if (vec.at(i) < vec.at(start + 1)) {
            if (k > vec.at(i) && k <= vec.at(end - 1)) {
                return search(vec, k, start, end);
            }
            else {
                end = i;
            }
        }
        else {
            if (k >= vec.at(start + 1) && k < vec.at(i)) {
                return search(vec, k, start, end);
            }
            else {
                start = i;
            }
        }
        if (k == vec.at(i)) {
            return i;
        }
        if (k < vec.at(i) && k > vec.at(i - 1)) {
            return -1;
        }
    }
    if (i != 0 && k == vec.at(i - 1)) {
        return i - 1;
    }
    else if (i == vec.size() || k != vec.at(i)) {
        return -1;
    }
    return i;
}

void test() {
    std::vector<int> arr = { 19, 21, 100, 101, 1, 4, 5, 7, 12 };
    assert(0 == broken_search(arr, 19));
    assert(1 == broken_search(arr, 21));
    assert(2 == broken_search(arr, 100));
    assert(3 == broken_search(arr, 101));
    assert(4 == broken_search(arr, 1));
    assert(5 == broken_search(arr, 4));
    assert(6 == broken_search(arr, 5));
    assert(7 == broken_search(arr, 7));
    assert(8 == broken_search(arr, 12));
    assert(-1 == broken_search(arr, 8));
    arr = { 5,1 };
    assert(1 == broken_search(arr, 1));
    assert(0 == broken_search(arr, 5));
    assert(-1 == broken_search(arr, 6));
    arr = { 1 };
    assert(0 == broken_search(arr, 1));
    assert(-1 == broken_search(arr, 2));
    arr = { 0, 2, 6, 7, 8, 9, 10 };
    assert(-1 == broken_search(arr, 5));
    arr = { 3, 6, 7 };
    assert(-1 == broken_search(arr, 8));
    assert(0 == broken_search(arr, 3));
    assert(1 == broken_search(arr, 6));
    assert(2 == broken_search(arr, 7));
}

int searchBrokenTree() {
    test();
    return 0;
}